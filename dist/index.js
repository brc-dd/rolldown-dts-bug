import MarkdownIt from "markdown-it";

//#region \0rolldown/runtime.js
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
			key = keys[i];
			if (!__hasOwnProp.call(to, key) && key !== except) {
				__defProp(to, key, {
					get: ((k) => from[k]).bind(null, key),
					enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
				});
			}
		}
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
//#region node_modules/.pnpm/markdown-it-attrs@4.3.1_markdown-it@14.1.0/node_modules/markdown-it-attrs/utils.js
var require_utils = /* @__PURE__ */ __commonJSMin(((exports) => {
	/**
	* @typedef {import('.').Token} Token
	* @typedef {import('.').Options} Options
	* @typedef {import('.').AttributePair} AttributePair
	* @typedef {import('.').AllowedAttribute} AllowedAttribute
	* @typedef {import('.').DetectingStrRule} DetectingStrRule
	*/
	/**
	* parse {.class #id key=val} strings
	* @param {string} str: string to parse
	* @param {number} start: where to start parsing (including {)
	* @param {Options} options
	* @returns {AttributePair[]}: [['key', 'val'], ['class', 'red']]
	*/
	exports.getAttrs = function(str, start, options) {
		const allowedKeyChars = /[^\t\n\f />"'=]/;
		const pairSeparator = " ";
		const keySeparator = "=";
		const classChar = ".";
		const idChar = "#";
		const attrs = [];
		let key = "";
		let value = "";
		let parsingKey = true;
		let valueInsideQuotes = false;
		for (let i = start + options.leftDelimiter.length; i < str.length; i++) {
			if (str.slice(i, i + options.rightDelimiter.length) === options.rightDelimiter) {
				if (key !== "") attrs.push([key, value]);
				break;
			}
			const char_ = str.charAt(i);
			if (char_ === keySeparator && parsingKey) {
				parsingKey = false;
				continue;
			}
			if (char_ === classChar && key === "") {
				if (str.charAt(i + 1) === classChar) {
					key = "css-module";
					i += 1;
				} else key = "class";
				parsingKey = false;
				continue;
			}
			if (char_ === idChar && key === "") {
				key = "id";
				parsingKey = false;
				continue;
			}
			if (char_ === "\"" && value === "" && !valueInsideQuotes) {
				valueInsideQuotes = true;
				continue;
			}
			if (char_ === "\"" && valueInsideQuotes) {
				valueInsideQuotes = false;
				continue;
			}
			if (char_ === pairSeparator && !valueInsideQuotes) {
				if (key === "") continue;
				attrs.push([key, value]);
				key = "";
				value = "";
				parsingKey = true;
				continue;
			}
			if (parsingKey && char_.search(allowedKeyChars) === -1) continue;
			if (parsingKey) {
				key += char_;
				continue;
			}
			value += char_;
		}
		if (options.allowedAttributes && options.allowedAttributes.length) {
			const allowedAttributes = options.allowedAttributes;
			return attrs.filter(function(attrPair) {
				const attr = attrPair[0];
				/**
				* @param {AllowedAttribute} allowedAttribute
				*/
				function isAllowedAttribute(allowedAttribute) {
					return attr === allowedAttribute || allowedAttribute instanceof RegExp && allowedAttribute.test(attr);
				}
				return allowedAttributes.some(isAllowedAttribute);
			});
		}
		return attrs;
	};
	/**
	* add attributes from [['key', 'val']] list
	* @param {AttributePair[]} attrs: [['key', 'val']]
	* @param {Token} token: which token to add attributes
	* @returns token
	*/
	exports.addAttrs = function(attrs, token) {
		for (let j = 0, l = attrs.length; j < l; ++j) {
			const key = attrs[j][0];
			if (key === "class") token.attrJoin("class", attrs[j][1]);
			else if (key === "css-module") token.attrJoin("css-module", attrs[j][1]);
			else token.attrPush(attrs[j]);
		}
		return token;
	};
	/**
	* Does string have properly formatted curly?
	*
	* start: '{.a} asdf'
	* end: 'asdf {.a}'
	* only: '{.a}'
	*
	* @param {'start'|'end'|'only'} where to expect {} curly. start, end or only.
	* @param {Options} options
	* @return {DetectingStrRule} Function which testes if string has curly.
	*/
	exports.hasDelimiters = function(where, options) {
		if (!where) throw new Error("Parameter `where` not passed. Should be \"start\", \"end\" or \"only\".");
		/**
		* @param {string} str
		* @return {boolean}
		*/
		return function(str) {
			const minCurlyLength = options.leftDelimiter.length + 1 + options.rightDelimiter.length;
			if (!str || typeof str !== "string" || str.length < minCurlyLength) return false;
			/**
			* @param {string} curly
			*/
			function validCurlyLength(curly) {
				const isClass = curly.charAt(options.leftDelimiter.length) === ".";
				const isId = curly.charAt(options.leftDelimiter.length) === "#";
				return isClass || isId ? curly.length >= minCurlyLength + 1 : curly.length >= minCurlyLength;
			}
			let start, end, slice, nextChar;
			const rightDelimiterMinimumShift = minCurlyLength - options.rightDelimiter.length;
			switch (where) {
				case "start":
					slice = str.slice(0, options.leftDelimiter.length);
					start = slice === options.leftDelimiter ? 0 : -1;
					end = start === -1 ? -1 : str.indexOf(options.rightDelimiter, rightDelimiterMinimumShift);
					nextChar = str.charAt(end + options.rightDelimiter.length);
					if (nextChar && options.rightDelimiter.indexOf(nextChar) !== -1) end = -1;
					break;
				case "end":
					start = str.lastIndexOf(options.leftDelimiter);
					end = start === -1 ? -1 : str.indexOf(options.rightDelimiter, start + rightDelimiterMinimumShift);
					end = end === str.length - options.rightDelimiter.length ? end : -1;
					break;
				case "only":
					slice = str.slice(0, options.leftDelimiter.length);
					start = slice === options.leftDelimiter ? 0 : -1;
					slice = str.slice(str.length - options.rightDelimiter.length);
					end = slice === options.rightDelimiter ? str.length - options.rightDelimiter.length : -1;
					break;
				default: throw new Error(`Unexpected case ${where}, expected 'start', 'end' or 'only'`);
			}
			return start !== -1 && end !== -1 && validCurlyLength(str.substring(start, end + options.rightDelimiter.length));
		};
	};
	/**
	* Removes last curly from string.
	* @param {string} str
	* @param {Options} options
	*/
	exports.removeDelimiter = function(str, options) {
		const start = escapeRegExp(options.leftDelimiter);
		const end = escapeRegExp(options.rightDelimiter);
		const curly = new RegExp("[ \\n]?" + start + "[^" + start + end + "]+" + end + "$");
		const pos = str.search(curly);
		return pos !== -1 ? str.slice(0, pos) : str;
	};
	/**
	* Escapes special characters in string s such that the string
	* can be used in `new RegExp`. For example "[" becomes "\\[".
	*
	* @param {string} s Regex string.
	* @return {string} Escaped string.
	*/
	function escapeRegExp(s) {
		return s.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
	}
	exports.escapeRegExp = escapeRegExp;
	/**
	* find corresponding opening block
	* @param {Token[]} tokens
	* @param {number} i
	*/
	exports.getMatchingOpeningToken = function(tokens, i) {
		if (tokens[i].type === "softbreak") return false;
		if (tokens[i].nesting === 0) return tokens[i];
		const level = tokens[i].level;
		const type = tokens[i].type.replace("_close", "_open");
		for (; i >= 0; --i) if (tokens[i].type === type && tokens[i].level === level) return tokens[i];
		return false;
	};
	/**
	* from https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js
	*/
	const HTML_ESCAPE_TEST_RE = /[&<>"]/;
	const HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
	const HTML_REPLACEMENTS = {
		"&": "&amp;",
		"<": "&lt;",
		">": "&gt;",
		"\"": "&quot;"
	};
	/**
	* @param {string} ch
	* @returns {string}
	*/
	function replaceUnsafeChar(ch) {
		return HTML_REPLACEMENTS[ch];
	}
	/**
	* @param {string} str
	* @returns {string}
	*/
	exports.escapeHtml = function(str) {
		if (HTML_ESCAPE_TEST_RE.test(str)) return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
		return str;
	};
}));

//#endregion
//#region node_modules/.pnpm/markdown-it-attrs@4.3.1_markdown-it@14.1.0/node_modules/markdown-it-attrs/patterns.js
var require_patterns = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* If a pattern matches the token stream,
	* then run transform.
	*/
	const utils = require_utils();
	/**
	* @param {import('.').Options} options
	* @returns {import('.').CurlyAttrsPattern[]}
	*/
	module.exports = (options) => {
		const __hr = new RegExp("^ {0,3}[-*_]{3,} ?" + utils.escapeRegExp(options.leftDelimiter) + "[^" + utils.escapeRegExp(options.rightDelimiter) + "]");
		return [
			{
				name: "fenced code blocks",
				tests: [{
					shift: 0,
					block: true,
					info: utils.hasDelimiters("end", options)
				}],
				transform: (tokens, i) => {
					const token = tokens[i];
					const start = token.info.lastIndexOf(options.leftDelimiter);
					const attrs = utils.getAttrs(token.info, start, options);
					utils.addAttrs(attrs, token);
					token.info = utils.removeDelimiter(token.info, options);
				}
			},
			{
				name: "inline nesting 0",
				tests: [{
					shift: 0,
					type: "inline",
					children: [{
						shift: -1,
						type: (str) => str === "image" || str === "code_inline"
					}, {
						shift: 0,
						type: "text",
						content: utils.hasDelimiters("start", options)
					}]
				}],
				transform: (tokens, i, j) => {
					const token = tokens[i].children[j];
					const endChar = token.content.indexOf(options.rightDelimiter);
					const attrToken = tokens[i].children[j - 1];
					const attrs = utils.getAttrs(token.content, 0, options);
					utils.addAttrs(attrs, attrToken);
					if (token.content.length === endChar + options.rightDelimiter.length) tokens[i].children.splice(j, 1);
					else token.content = token.content.slice(endChar + options.rightDelimiter.length);
				}
			},
			{
				name: "tables",
				tests: [
					{
						shift: 0,
						type: "table_close"
					},
					{
						shift: 1,
						type: "paragraph_open"
					},
					{
						shift: 2,
						type: "inline",
						content: utils.hasDelimiters("only", options)
					}
				],
				transform: (tokens, i) => {
					const token = tokens[i + 2];
					const tableOpen = utils.getMatchingOpeningToken(tokens, i);
					const attrs = utils.getAttrs(token.content, 0, options);
					utils.addAttrs(attrs, tableOpen);
					tokens.splice(i + 1, 3);
				}
			},
			{
				name: "tables thead metadata",
				tests: [
					{
						shift: 0,
						type: "tr_close"
					},
					{
						shift: 1,
						type: "thead_close"
					},
					{
						shift: 2,
						type: "tbody_open"
					}
				],
				transform: (tokens, i) => {
					const tr = utils.getMatchingOpeningToken(tokens, i);
					const th = tokens[i - 1];
					let colsnum = 0;
					let n = i;
					while (--n) {
						if (tokens[n] === tr) {
							tokens[n - 1].meta = Object.assign({}, tokens[n + 2].meta, { colsnum });
							break;
						}
						colsnum += (tokens[n].level === th.level && tokens[n].type === th.type) >> 0;
					}
					tokens[i + 2].meta = Object.assign({}, tokens[i + 2].meta, { colsnum });
				}
			},
			{
				name: "tables tbody calculate",
				tests: [{
					shift: 0,
					type: "tbody_close",
					hidden: false
				}],
				transform: (tokens, i) => {
					/** index of the tbody beginning */
					let idx = i - 2;
					while (idx > 0 && "tbody_open" !== tokens[--idx].type);
					const calc = tokens[idx].meta.colsnum >> 0;
					if (calc < 2) return;
					const level = tokens[i].level + 2;
					for (let n = idx; n < i; n++) {
						if (tokens[n].level > level) continue;
						const token = tokens[n];
						const rows = token.hidden ? 0 : token.attrGet("rowspan") >> 0;
						const cols = token.hidden ? 0 : token.attrGet("colspan") >> 0;
						if (rows > 1) {
							let colsnum = calc - (cols > 0 ? cols : 1);
							for (let k = n, num = rows; num > 1; k++) if ("tr_open" == tokens[k].type) {
								tokens[k].meta = Object.assign({}, tokens[k].meta);
								if (tokens[k].meta && tokens[k].meta.colsnum) colsnum -= 1;
								tokens[k].meta.colsnum = colsnum;
								num--;
							}
						}
						if ("tr_open" == token.type && token.meta && token.meta.colsnum) {
							const max = token.meta.colsnum;
							for (let k = n, num = 0; k < i; k++) {
								if ("td_open" == tokens[k].type) num += 1;
								else if ("tr_close" == tokens[k].type) break;
								num > max && (tokens[k].hidden || hidden(tokens[k]));
							}
						}
						if (cols > 1) {
							/** @type {number[]} index of one row's children */
							const one = [];
							/** last index of the row's children */
							let end = n + 3;
							/** number of the row's children */
							let num = calc;
							for (let k = n; k > idx; k--) if ("tr_open" == tokens[k].type) {
								num = tokens[k].meta && tokens[k].meta.colsnum || num;
								break;
							} else if ("td_open" === tokens[k].type) one.unshift(k);
							for (let k = n + 2; k < i; k++) if ("tr_close" == tokens[k].type) {
								end = k;
								break;
							} else if ("td_open" == tokens[k].type) one.push(k);
							const off = one.indexOf(n);
							let real = num - off;
							real = real > cols ? cols : real;
							cols > real && token.attrSet("colspan", real + "");
							for (let k = one.slice(num + 1 - calc - real)[0]; k < end; k++) tokens[k].hidden || hidden(tokens[k]);
						}
					}
				}
			},
			{
				name: "inline attributes",
				tests: [{
					shift: 0,
					type: "inline",
					children: [{
						shift: -1,
						nesting: -1
					}, {
						shift: 0,
						type: "text",
						content: utils.hasDelimiters("start", options)
					}]
				}],
				transform: (tokens, i, j) => {
					const token = tokens[i].children[j];
					const content = token.content;
					const attrs = utils.getAttrs(content, 0, options);
					const openingToken = utils.getMatchingOpeningToken(tokens[i].children, j - 1);
					utils.addAttrs(attrs, openingToken);
					token.content = content.slice(content.indexOf(options.rightDelimiter) + options.rightDelimiter.length);
				}
			},
			{
				name: "list softbreak",
				tests: [{
					shift: -2,
					type: "list_item_open"
				}, {
					shift: 0,
					type: "inline",
					children: [{
						position: -2,
						type: "softbreak"
					}, {
						position: -1,
						type: "text",
						content: utils.hasDelimiters("only", options)
					}]
				}],
				transform: (tokens, i, j) => {
					const content = tokens[i].children[j].content;
					const attrs = utils.getAttrs(content, 0, options);
					let ii = i - 2;
					while (tokens[ii - 1] && tokens[ii - 1].type !== "ordered_list_open" && tokens[ii - 1].type !== "bullet_list_open") ii--;
					utils.addAttrs(attrs, tokens[ii - 1]);
					tokens[i].children = tokens[i].children.slice(0, -2);
				}
			},
			{
				name: "list double softbreak",
				tests: [
					{
						shift: 0,
						type: (str) => str === "bullet_list_close" || str === "ordered_list_close"
					},
					{
						shift: 1,
						type: "paragraph_open"
					},
					{
						shift: 2,
						type: "inline",
						content: utils.hasDelimiters("only", options),
						children: (arr) => arr.length === 1
					},
					{
						shift: 3,
						type: "paragraph_close"
					}
				],
				transform: (tokens, i) => {
					const content = tokens[i + 2].content;
					const attrs = utils.getAttrs(content, 0, options);
					const openingToken = utils.getMatchingOpeningToken(tokens, i);
					utils.addAttrs(attrs, openingToken);
					tokens.splice(i + 1, 3);
				}
			},
			{
				name: "list item end",
				tests: [{
					shift: -2,
					type: "list_item_open"
				}, {
					shift: 0,
					type: "inline",
					children: [{
						position: -1,
						type: "text",
						content: utils.hasDelimiters("end", options)
					}]
				}],
				transform: (tokens, i, j) => {
					const token = tokens[i].children[j];
					const content = token.content;
					const attrs = utils.getAttrs(content, content.lastIndexOf(options.leftDelimiter), options);
					utils.addAttrs(attrs, tokens[i - 2]);
					const trimmed = content.slice(0, content.lastIndexOf(options.leftDelimiter));
					token.content = last(trimmed) !== " " ? trimmed : trimmed.slice(0, -1);
				}
			},
			{
				name: "\n{.a} softbreak then curly in start",
				tests: [{
					shift: 0,
					type: "inline",
					children: [{
						position: -2,
						type: "softbreak"
					}, {
						position: -1,
						type: "text",
						content: utils.hasDelimiters("only", options)
					}]
				}],
				transform: (tokens, i, j) => {
					const token = tokens[i].children[j];
					const attrs = utils.getAttrs(token.content, 0, options);
					let ii = i + 1;
					while (tokens[ii + 1] && tokens[ii + 1].nesting === -1) ii++;
					const openingToken = utils.getMatchingOpeningToken(tokens, ii);
					utils.addAttrs(attrs, openingToken);
					tokens[i].children = tokens[i].children.slice(0, -2);
				}
			},
			{
				name: "horizontal rule",
				tests: [
					{
						shift: 0,
						type: "paragraph_open"
					},
					{
						shift: 1,
						type: "inline",
						children: (arr) => arr.length === 1,
						content: (str) => str.match(__hr) !== null
					},
					{
						shift: 2,
						type: "paragraph_close"
					}
				],
				transform: (tokens, i) => {
					const token = tokens[i];
					token.type = "hr";
					token.tag = "hr";
					token.nesting = 0;
					const content = tokens[i + 1].content;
					const start = content.lastIndexOf(options.leftDelimiter);
					const attrs = utils.getAttrs(content, start, options);
					utils.addAttrs(attrs, token);
					token.markup = content;
					tokens.splice(i + 1, 2);
				}
			},
			{
				name: "end of block",
				tests: [{
					shift: 0,
					type: "inline",
					children: [{
						position: -1,
						content: utils.hasDelimiters("end", options),
						type: (t) => t !== "code_inline" && t !== "math_inline"
					}]
				}],
				transform: (tokens, i, j) => {
					const token = tokens[i].children[j];
					const content = token.content;
					const attrs = utils.getAttrs(content, content.lastIndexOf(options.leftDelimiter), options);
					let ii = i + 1;
					do
						if (tokens[ii] && tokens[ii].nesting === -1) break;
					while (ii++ < tokens.length);
					const openingToken = utils.getMatchingOpeningToken(tokens, ii);
					utils.addAttrs(attrs, openingToken);
					const trimmed = content.slice(0, content.lastIndexOf(options.leftDelimiter));
					token.content = last(trimmed) !== " " ? trimmed : trimmed.slice(0, -1);
				}
			}
		];
	};
	function last(arr) {
		return arr.slice(-1)[0];
	}
	/**
	* Hidden table's cells and them inline children,
	* specially cast inline's content as empty
	* to prevent that escapes the table's box model
	* @see https://github.com/markdown-it/markdown-it/issues/639
	* @param {import('.').Token} token
	*/
	function hidden(token) {
		token.hidden = true;
		token.children && token.children.forEach((t) => (t.content = "", hidden(t), void 0));
	}
}));

//#endregion
//#region node_modules/.pnpm/markdown-it-attrs@4.3.1_markdown-it@14.1.0/node_modules/markdown-it-attrs/index.js
var require_markdown_it_attrs = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const patternsConfig = require_patterns();
	/**
	* @typedef {import('markdown-it')} MarkdownIt
	*
	* @typedef {import('markdown-it/lib/rules_core/state_core.mjs').default} StateCore
	*
	* @typedef {import('markdown-it/lib/token.mjs').default} Token
	*
	* @typedef {import('markdown-it/lib/token.mjs').Nesting} Nesting
	*
	* @typedef {Object} Options
	* @property {!string} leftDelimiter left delimiter, default is `{`(left curly bracket)
	* @property {!string} rightDelimiter right delimiter, default is `}`(right curly bracket)
	* @property {AllowedAttribute[]} allowedAttributes empty means no limit
	*
	* @typedef {string|RegExp} AllowedAttribute rule of allowed attribute
	*
	* @typedef {[string, string]} AttributePair
	*
	* @typedef {[number, number]} SourceLineInfo
	*
	* @typedef {Object} CurlyAttrsPattern
	* @property {string} name
	* @property {DetectingRule[]} tests
	* @property {(tokens: Token[], i: number, j?: number) => void} transform
	*
	* @typedef {Object} MatchedResult
	* @property {boolean} match true means matched
	* @property {number?} j postion index number of Array<{@link Token}>
	*
	* @typedef {(str: string) => boolean} DetectingStrRule
	*
	* @typedef {Object} DetectingRule rule for testing {@link Token}'s properties
	* @property {number=} shift offset index number of Array<{@link Token}>
	* @property {number=} position fixed index number of Array<{@link Token}>
	* @property {(string | DetectingStrRule)=} type
	* @property {(string | DetectingStrRule)=} tag
	* @property {DetectingRule[]=} children
	* @property {(string | DetectingStrRule)=} content
	* @property {(string | DetectingStrRule)=} markup
	* @property {(string | DetectingStrRule)=} info
	* @property {Nesting=} nesting
	* @property {number=} level
	* @property {boolean=} block
	* @property {boolean=} hidden
	* @property {AttributePair[]=} attrs
	* @property {SourceLineInfo[]=} map
	* @property {any=} meta
	*/
	/** @type {Options} */
	const defaultOptions = {
		leftDelimiter: "{",
		rightDelimiter: "}",
		allowedAttributes: []
	};
	/**
	* @param {MarkdownIt} md
	* @param {Options=} options_
	*/
	module.exports = function attributes(md, options_) {
		let options = Object.assign({}, defaultOptions);
		options = Object.assign(options, options_);
		const patterns = patternsConfig(options);
		/**
		* @param {StateCore} state
		*/
		function curlyAttrs(state) {
			const tokens = state.tokens;
			for (let i = 0; i < tokens.length; i++) for (let p = 0; p < patterns.length; p++) {
				const pattern = patterns[p];
				let j = null;
				if (pattern.tests.every((t) => {
					const res = test(tokens, i, t);
					if (res.j !== null) j = res.j;
					return res.match;
				})) try {
					pattern.transform(tokens, i, j);
					if (pattern.name === "inline attributes" || pattern.name === "inline nesting 0") p--;
				} catch (error) {
					console.error(`markdown-it-attrs: Error in pattern '${pattern.name}': ${error.message}`);
					console.error(error.stack);
				}
			}
		}
		md.core.ruler.before("linkify", "curly_attributes", curlyAttrs);
	};
	/**
	* Test if t matches token stream.
	*
	* @param {Token[]} tokens
	* @param {number} i
	* @param {DetectingRule} t
	* @returns {MatchedResult}
	*/
	function test(tokens, i, t) {
		/** @type {MatchedResult} */
		const res = {
			match: false,
			j: null
		};
		const ii = t.shift !== void 0 ? i + t.shift : t.position;
		if (t.shift !== void 0 && ii < 0) return res;
		const token = get(tokens, ii);
		if (token === void 0) return res;
		for (const key of Object.keys(t)) {
			if (key === "shift" || key === "position") continue;
			if (token[key] === void 0) return res;
			if (key === "children" && isArrayOfObjects(t.children)) {
				if (token.children.length === 0) return res;
				let match;
				/** @type {DetectingRule[]} */
				const childTests = t.children;
				/** @type {Token[]} */
				const children = token.children;
				if (childTests.every((tt) => tt.position !== void 0)) {
					match = childTests.every((tt) => test(children, tt.position, tt).match);
					if (match) {
						const j = last(childTests).position;
						res.j = j >= 0 ? j : children.length + j;
					}
				} else for (let j = 0; j < children.length; j++) {
					match = childTests.every((tt) => test(children, j, tt).match);
					if (match) {
						res.j = j;
						break;
					}
				}
				if (match === false) return res;
				continue;
			}
			switch (typeof t[key]) {
				case "boolean":
				case "number":
				case "string":
					if (token[key] !== t[key]) return res;
					break;
				case "function":
					if (!t[key](token[key])) return res;
					break;
				case "object": if (isArrayOfFunctions(t[key])) {
					if (t[key].every((tt) => tt(token[key])) === false) return res;
					break;
				}
				default: throw new Error(`Unknown type of pattern test (key: ${key}). Test should be of type boolean, number, string, function or array of functions.`);
			}
		}
		res.match = true;
		return res;
	}
	function isArrayOfObjects(arr) {
		return Array.isArray(arr) && arr.length && arr.every((i) => typeof i === "object");
	}
	function isArrayOfFunctions(arr) {
		return Array.isArray(arr) && arr.length && arr.every((i) => typeof i === "function");
	}
	/**
	* Get n item of array. Supports negative n, where -1 is last
	* element in array.
	* @param {Token[]} arr
	* @param {number} n
	* @returns {Token=}
	*/
	function get(arr, n) {
		return n >= 0 ? arr[n] : arr[arr.length + n];
	}
	/**
	* get last element of array, safe - returns {} if not found
	* @param {DetectingRule[]} arr
	* @returns {DetectingRule}
	*/
	function last(arr) {
		return arr.slice(-1)[0] || {};
	}
}));

//#endregion
//#region src/index.ts
var import_markdown_it_attrs = /* @__PURE__ */ __toESM(require_markdown_it_attrs(), 1);
function markdownToHtml(markdown, options) {
	const md = new MarkdownIt();
	(0, import_markdown_it_attrs.default)(md, options.attrs);
	return md.render(markdown);
}

//#endregion
export { markdownToHtml };